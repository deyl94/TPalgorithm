/*
 *        Name: main.cpp
 *  Created on: Dec 12, 2013
 *      Author: roland
 *   Copiright: 2013 All rights reserved
 */

 /*
 * 2_1. Телефонизация в год лошади. В наступающий год лошади телефонная
 * компания решила всем новым абонентам выдавать “красивые” телефонные
 * номера. Номер считается красивым если его можно набрать, перемещаясь
 * по циферблату телефона ходом шахматного коня.
 * Циферблат выглядит следующим образом:
 *
 *    1 2 3
 *    4 5 6
 *    7 8 9
 *      0
 *
 * Телефонный номер не может начанаться с “0” и  “8”.
 * Например “красивым” 7-значным номером считается 1616161.
 * Требуется посчитать какое максимальное количество абонентов сможет
 * привлечь компания.
 * Формат входных данных:
 * На вход подается длина номера N.
 * Формат выходных данных:
 * Требуется вывести количество N-значных комбинаций,
 * удовлетворяющих условию задачи.
 */

#include <iostream>

size_t horseNumber( size_t, size_t** );

int main()
{
    size_t length;
    std::cin >> length;

    // Матрица результатов.
    size_t** result = new size_t* [10];
    for ( size_t i = 0; i < 10; ++i )
        result[i] = new size_t [length];

    std::cout << horseNumber(length, result) << "\n";

    // Удаление матрицы результатов.
    for ( size_t i = 0; i < 10; ++i )
        delete[] result[i];
    delete[] result;

    return 0;
}

size_t horseNumber( size_t length, size_t** result )
{
    // Mатрица возможных переходов "конем", где первый индекс означает цифру из
    // которой идем, значения элементов - куда мы можем попасть,
    // 999 - невозможная ситуация.
    size_t tel [10][3] = {{4, 6, 999},     // из 0
                          {8, 6, 999},     // из 1
                          {7, 9, 999},     // из 2
                          {4, 8, 999},     // из 3
                          {3, 9, 0},       // из 4
                          {999, 999, 999}, // из 5
                          {1, 7, 0},       // из 6
                          {2, 6, 999},     // из 7
                          {3, 1, 999},     // из 8
                          {2, 4, 999}};    // из 9

    // Кеширование результатов, для ускорения вычислений.
    // В таблице result первый индекс означает первое число, второй длину
    // номера, значение элемента - количество возможных номеров.
    for ( size_t i = 0; i < length; ++i )
        for ( size_t j = 0; j < 10; ++j )
            if ( i == 0 )
            {
                result[j][i] = 1;
            }
            else
                if ( j != 5 && j != 4 && j != 6)
                    result[j][i] = result[tel[j][0]][i - 1] +
                                   result[tel[j][1]][i - 1];
                else
                    if ( j != 5 )
                        result[j][i] = result[tel[j][0]][i - 1] +
                                       result[tel[j][1]][i - 1] +
                                       result[tel[j][2]][i - 1];

    // Считаем все возможные номера, исключая первый 0 и 8 и цифру 5.
    size_t sum = 0;
    for ( size_t i = 1; i < 10; ++i )
        if ( i != 5 && i != 8 )
            sum += result[i][length - 1];

    // При длине 1 может быть номер "5", в других ситуациях
    // не может быть 5 нигде.
    if ( length == 1 )
        ++sum;

    return sum;
}
